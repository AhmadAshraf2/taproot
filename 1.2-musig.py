#!/usr/bin/env python
# coding: utf-8

# In[ ]:


import util
from test_framework.key import ECKey, ECPubKey, generate_key_pair, generate_bip340_key_pair, generate_schnorr_nonce
from test_framework.messages import sha256
from test_framework.musig import aggregate_musig_signatures, aggregate_schnorr_nonces, generate_musig_key, sign_musig
from test_framework.script import tagged_hash


# # 1.2 Introduction to n-of-n MuSig
# 
# * Public Key Generation
# * Signing
#     * Nonce Aggregation
#     * Signature Aggregation
# 
# In this chapter, we introduce the interactive [MuSig protocol](https://eprint.iacr.org/2018/068.pdf) which allows n-of-n participants to jointly create and spend taproot or tapscript outputs using aggregated schnorr signatures. 
# 
# Using a signature aggregation scheme like MuSig has two significant advantages over using Script's `OP_CHECKMULTISIG` and tapscript's `OP_CHECKSIGADD` opcodes:
# 
# * **Transaction Size/Fees**: an aggregate MuSig pubkey and signature is indistinguishable from a single-key pubkey and signature, meaning that the transaction size (and required fee) for a multi-key output are the same as for a single-key output.
# * **Privacy and Fungibility**: an aggregate MuSig pubkey and signature is indistinguishable from a single-key pubkey and signature, making it impossible for anyone to use the public block chain data to identify where a multi-key scheme has been used.
# 
# The MuSig protocol covers both the initial setup (generating an aggregate pubkey for all participants), and the signing protocol (creating a valid signature for the aggregate pubkey). The signing requires multiple rounds of communication between the individual signers.
# 
# BIP340 is linear in the nonce points and public keys, which means that public keys, nonces and signatures can be aggregated. A very naive multiparty signature scheme could be achieved by simply summing the individual pubkeys to generate an aggregate pubkey, each participant signing with a shared nonce, and then summing the signatures. Such a scheme would be vulnerable to both the [key cancellation attack](https://tlu.tarilabs.com/cryptography/digital_signatures/introduction_schnorr_signatures.html#key-cancellation-attack) and private key extraction by exploiting weak or known nonces. Countering these attacks is what adds some complexity to the MuSig protocol.

# ![test](images/musig_intro_0.jpg)

# ## Public Key Generation
# 
# To counter the key cancellation attack, each participant's pubkey is _tweaked_ by a _challenge factor,_ which is generated by hashing all the participants' pubkeys together. Doing this ensures that no individual participant (or group of participants) is able to create a pubkey that cancels out other participants' pubkeys.
# 
# The challenge factor is unique for each participant, but all challenge factors are based on a hash of all participants' pubkeys.
# 
# No interactive round-trips are required in this step. As long as everyone can get all the public keys involved (through communication, a coordinator or offline) then they can compute the challenge factors and the aggregate public key locally.

# ![test](images/musig_intro_1.jpg)

# #### 1.2.1 _Programming Exercise:_ Compute 3-of-3 MuSig public key
# 
# In this exercise, we'll use the `generate_musig_key(pubkey_list)` function to generate challenge factors for each participant and an aggregate MuSig pubkey.
# 
# `generate_musig_key(pubkey_list)` takes a list of the participants' public keys `generate_musig_key([ECPubKey0, ECPubKey1, ...])` and returns a challenge map and the aggregate pubkey:
# * The challenge map contains `ECPubKey_i, challenge_data_i` key - value pairs.
# * The aggregate pubkey is an `ECPubKey` object.

# In[ ]:


# Compute key pairs
privkey1, pubkey1 = generate_key_pair(sha256(b'key0'))
privkey2, pubkey2 = generate_key_pair(sha256(b'key1'))
privkey3, pubkey3 = generate_key_pair(sha256(b'key2'))
pubkeys = [pubkey1, pubkey2, pubkey3]

# Compute key challenges
# Method: use generate_musig_key() on the list of pubkeys.
# generate_musig_key() returns a challenge map and the aggregate public key.
c_map, pubkey_agg =  # TODO: implement
print("Aggregated Public Key is {}\n".format(pubkey_agg.get_bytes().hex()))

# Multiply key pairs by challenge factor
privkey1_c =  # TODO: implement
privkey2_c =  # TODO: implement
privkey3_c =  # TODO: implement
pubkey1_c =  # TODO: implement
pubkey2_c =  # TODO: implement
pubkey3_c =  # TODO: implement

# Determine if the private and public keys need to be negated. 
# Hint: The aggregate public key is the one that needs to be valid.
if # TODO: implement

print("Tweaked privkey1 is {}".format(privkey1_c))
print("Tweaked privkey2 is {}".format(privkey2_c))
print("Tweaked privkey3 is {}".format(privkey3_c))

assert privkey1_c.secret == 104717570570407299858230629579807834166658508605015363884161538594382975780625
assert privkey2_c.secret == 65554880484297966965546994775376394861215085064604177497808278620612854069980
assert privkey3_c.secret == 106998690642216524894360365246223287721822845133760006050846956016514597569168

print("\nSuccess!")


# ## Signing 
# 
# ### Nonce generation
# 
# The first step of creating a MuSig signature requires each signer to generate their own nonce and nonce point. The participants then exchange those nonces points and an aggregate nonce point is derived by summing all the nonce points.
# 
# The security proof for MuSig requires that nonces are randomly generated and are independent of each other. To ensure that no individual participant (or group of participants) can create their nonce as a function of the other nonces or individually control what the aggregate nonce point will be, there is an initial round of exchanging hash commitments to the individual nonce points.
# 
# Individual participants should only exchange their nonce point when they have received all commitments, and only proceed with signing if all nonce points match their commitments.
# 
# Finally, if the aggregate nonce does not have an even y-coordinate, then it is negated and all individual nonces are also negated.

# ![test](images/musig_intro_2.jpg)

# #### 1.2.2 _Programming Exercise:_ Compute 3-of-3 MuSig nonce
# 
# In this exercise, we'll generate nonces for individual participants, calculate the nonce point commitments, and then generate an aggregate nonce point.

# In[ ]:


# Generate nonces and nonce points
# We set the nonces manually here for testing purposes, but usually we'll call generate_schnorr_nonce()
# to generate a random nonce point
# Method: generate_schnorr_nonce() with no argument generates a random nonce
k1 = ECKey().set(101)
k2 = ECKey().set(222)
k3 = ECKey().set(333)
test_k1 = ECKey().set(k1.secret)
test_k2 = ECKey().set(k2.secret)
test_k3 = ECKey().set(k3.secret)

# Method: use get_pubkey() to get the associated nonce point.
R1 =  # TODO: implement
R2 =  # TODO: implement
R3 =  # TODO: implement

# Round 1: Generate nonce point commitments and exchange them
# Method: use sha256() on the nonce point. sha256() takes a bytes object, so extract the bytes from the nonce point.
R1_digest =  # TODO: implement
R2_digest =  # TODO: implement
R3_digest =  # TODO: implement

# Round 2: Exchange the nonce points. Each participant verifies that the nonce point commitment matches the nonce point.
assert R1_digest.hex() == "38018cfa00483e751b166e7d982a5bb8264fb3309739c2f432e79791a1c9aaf7"
assert R2_digest.hex() == "9eb8fac583a9d83d4753c454e4ab4de833b3496d093a6f2df507a6a39424c745"
assert R3_digest.hex() == "103ea7eeb151bc6bd2c1e54ecaaad303b1c022bb205c5430daac796924a80ed0"

# Aggregate nonces
# Tip: Add the individual nonce points together. If the aggregated nonce does not have an even Y
# then negate the aggregate nonce and individual nonce scalars.
R_agg =  # TODO: implement
if  # TODO: implement





print("Individual nonce scalars:\n\t{}, \n\t{}, \n\t{}.\n".format(k1, k2, k3))
print("Aggregate nonce point: {}\n".format(R_agg))

# Test your solution against the aggregate_schnorr_nonces() helper function.
# aggregate_schnorr_nonces() aggregates the nonces and returns whether the individual nonces need to be negated.
test_R_agg, negated = aggregate_schnorr_nonces([R1, R2, R3])
if negated:
    test_k1.negate()
    test_k2.negate()
    test_k3.negate()

assert R_agg == test_R_agg
assert k1 == test_k1
assert k2 == test_k2
assert k3 == test_k3

print("Success!")


# ### Signature Aggregation
# 
# Once all participants have their individual nonces and the aggregate nonce point, they can all sign individually. 
# 
# The partial `s` values are then exchanged and summed together. The aggregate `s` value and aggregate nonce point `R` form a valid BIP340 signature for the aggregate pubkey.
# 
# Notice that the hash expressions are identical in all signatures, which makes aggregation possible.

# ![test](images/musig_intro_3.jpg)

# #### 1.2.3 _Programming exercise:_ Compute aggregated MuSig signature
# 
# In this exercise, we'll create partial signatures and then aggregate them to create a valid signature.
# 
# Use the `sign_musig()` function to create partial signatures. `sign_musig()` takes:
#   - the individual participant's challenge-factor-modified private key (an `ECKey` object)
#   - the invididual participant's nonce scalar (an `ECKey` object)
#   - the aggregate nonce point (an `ECPubKey` object)
#   - the aggregate pubkey (an `ECPubKey` object)
#   - the message (a 32 byte `bytes` object)
# 
# and returns a partial signature (an int containing the partial `s` value).
# 
# Use `aggregate_musig_signatures()` to aggregate the partial signatures. `aggregate_musig_signatures()` takes a list of partial signatures, and the aggregate nonce point and returns the final signature.
# 
# Use `ECPubKey.verify_schnorr(sig, msg)` to verify that the signature is valid.

# In[ ]:


msg = sha256(b'transaction')

# Generate partial signatures
# Method: use sign_musig() with:
#     - individual (tweaked) privkey
#     - individual nonce scalar
#     - aggregate nonce point
#     - aggregate pubkey
#     - msg
s1 =  # TODO: implement
s2 =  # TODO: implement
s3 =  # TODO: implement

print("Partial signatures:\n\t{}\n\t{}\n\t{}\n".format(s1, s2, s3))

# Aggregate signatures
# Method: use aggregate_musig_signatures with list of individual signatures along with the aggregate nonce point
sig_agg =  # TODO: implement
print("Aggregate signature:\n\t{}\n".format(sig_agg.hex()))

# Verify signature against aggregate public key
assert pubkey_agg.verify_schnorr(sig_agg, msg)
print("Success! Signature verifies against aggregate pubkey")


# **Congratulations!** In this chapter, you have:
# 
# - Learned about the MuSig multi-signature scheme.
# - Computed an aggregate public key that multiplies individual public keys by _challenge factors_ to counter the rogue key attack.
# - Exchanged nonce point commitments, and then the nonce points themselves, and generated an aggregate nonce point.
# - Signed individually and then aggregated individual `s` values to create a valid signature for the aggregate public key.
